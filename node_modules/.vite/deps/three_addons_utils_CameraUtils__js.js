import {
  MathUtils,
  Quaternion,
  Vector3
} from "./chunk-FHT34YR5.js";

// 3d/node_modules/three/examples/jsm/utils/CameraUtils.js
var _va = new Vector3();
var _vb = new Vector3();
var _vc = new Vector3();
var _vr = new Vector3();
var _vu = new Vector3();
var _vn = new Vector3();
var _vec = new Vector3();
var _quat = new Quaternion();
function frameCorners(camera, bottomLeftCorner, bottomRightCorner, topLeftCorner, estimateViewFrustum = false) {
  const pa = bottomLeftCorner, pb = bottomRightCorner, pc = topLeftCorner;
  const pe = camera.position;
  const n = camera.near;
  const f = camera.far;
  _vr.copy(pb).sub(pa).normalize();
  _vu.copy(pc).sub(pa).normalize();
  _vn.crossVectors(_vr, _vu).normalize();
  _va.copy(pa).sub(pe);
  _vb.copy(pb).sub(pe);
  _vc.copy(pc).sub(pe);
  const d = -_va.dot(_vn);
  const l = _vr.dot(_va) * n / d;
  const r = _vr.dot(_vb) * n / d;
  const b = _vu.dot(_va) * n / d;
  const t = _vu.dot(_vc) * n / d;
  _quat.setFromUnitVectors(_vec.set(0, 1, 0), _vu);
  camera.quaternion.setFromUnitVectors(_vec.set(0, 0, 1).applyQuaternion(_quat), _vn).multiply(_quat);
  camera.projectionMatrix.set(
    2 * n / (r - l),
    0,
    (r + l) / (r - l),
    0,
    0,
    2 * n / (t - b),
    (t + b) / (t - b),
    0,
    0,
    0,
    (f + n) / (n - f),
    2 * f * n / (n - f),
    0,
    0,
    -1,
    0
  );
  camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
  if (estimateViewFrustum) {
    camera.fov = MathUtils.RAD2DEG / Math.min(1, camera.aspect) * Math.atan((_vec.copy(pb).sub(pa).length() + _vec.copy(pc).sub(pa).length()) / _va.length());
  }
}
export {
  frameCorners
};
//# sourceMappingURL=three_addons_utils_CameraUtils__js.js.map
